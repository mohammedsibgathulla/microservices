1. What Is A Web Service?
- Software System designed to support interoperable machine-to-machine interaction over network.
- Designed for machine-to-machine or applicaion-to-application interaction.
- Should be interoperable (Any other kind of application should be able to talk to the application) - Not platform independent. Irrespective of technologies they should be able to talk to the webservice.
- It should allow communication over a network.

2. How Questions Related To Web Services
- How does data exchange between applications take place?
	It happens with Request & Response. They are the basic concepts behind webservices.
- How can we make web services platform independent?
	Request & Response should be platform indepndent.
	Two popular formats - XML
						- JSON
- How does Application A know the format of Request & Response?
	Service Definition: Every web service offers a Service Definition. 
	It specifies the following
		1. The Request/Respons Format.
		2. Request Structure.
		3. Response Structure.
		4. Endpoint. (How to call the service.)

3. Web Services - Key Terminology
 - Service Provider or Server - Which host the web service
 - Service Consumer or Client - Which consumes the web service
 - Service Definition - It is the contract b/n the service provider and the service consumer.
 - Transport: It defines how a service is called is it exposed over internet or is exposed over MQ.
 	It has two formats
 			1. HTTP - over the web.
 			2. MQ	- Communication over a queue.	

4. Web Service Groups
- SOAP - based :
- REST - styled :  	
- SOAP & REST are not really comparable. 
- REST defines ann architectural approach. Whereas SOAP poses restrictions on the format of XML which is exchanged between your service provider and the service consumer.
- SOAP stands for Simple Object Access Protocol. Actually it no longer stands for Simple Object Access Protocol. It's no longer an abbreviation anymore. SOAP is just like a request response. Any of those terms. SOAP is just a term. SOAP defines a specific way of building web services. In SOAP we use XML as the request exchange format.		

5. Introductions To RESTFUL Web Services
- REST stands for representational state transfer. It’s a term which is Coined by Roy Fielding. If you remember, Roy Fielding is the guy who also developed HTTP protocol.
- RESTful web services try to define services using the different concepts that are already present in HTTP. The most important abstraction in the REST is something called a resource. A resource is anything that you'd want to expose to the outside world through your application.

6. SOAP vs RESTFUl Web Services
- In SOAP the data exchange format is always XML that too specifically the SOAP XML with SOAP envelope header and body. Both your request and response should adhere to the SOAP Structure.
- In REST there is no strict date exchange format. You can exchange a XML, a JSON or any other format you would want use.
- As far as the service definitions are concerned SOAP uses WSDL. Web service definition language. REST does not have a standard definition language.
- As far as the transport protocol is concerned SOAP does not pose any restrictions at all. You can use web that is HTTP or you can use MQ. REST is very specific about making the best use of HTTP protocol. RESTful services are typically more easier to implement than SOAP.
- RESTful services are typically based on JSON which is an easy format to pass and do things with it and also with RESTful services. We don't really need to mandate really define a service definition. But with SOAP you have to define WSDL and there are a lot of complexities associated with parsing your XMLs as well.

7. Initializing A RESTful Services Project With Spring Boot
- Choose web, devtools, h2 & jpa in spring initializer and generate the project. 

8. Understanding the RESTful Services We Would Create 
- See the image.

9. Creating A HelloWorld Service
- See the project.

10. Enhancing The Hello World Service To Return A Bean
- See the project.

11. Quick Review of Spring Boot Auto Configuration And Dispatcher Servlet
- Refer .vtt file & image.

12. Enhancing The Hello World Service with A Path Variable
- See the project.

13. Creating User Bean And User Service
- See the project. 

14. Implementing GET Methods for User Resource
- See the project.

15. Implementing POST Method To create User Resource
- See the project.

16. Enhancing POST Method to return correct HTTP Status Code and Location
- See the project.

17. Implementing Exception Handling - 404 Resource Not Found
- See the project. 

18. Implementing Generic Exception Handling For All Resources
- See the project. 

19. Implementing DELETE Method To Delete a User Resource
- See the project. 

20. Implementing Validations for RESTful Services
- See the project.

21. Implementing HATEOAS for RESTful Services
- HATEOAS - Hyper Media As The Engine Of Application State
- In recent versions classes in the HATEOAS are update like Resource to EntityModel, ControlLinkBuilder to WebMvcLinkBuilder 

22. Internationalization For RESTful Services
- We have to configure the LocaleResolver & ResourceBundleMessageSource
- Default Locale: Locale.US
- See the project.

23. Internationalization For RESTful Services Part II
- Here we have used AcceptHeaderLocaleResolver instead of SessionLocaleResolver. We have removed ResourceBundleMessageSource and directly configured in application.properties file. This is the more best way to configure internalization.

24. Content Negotiation - Implementing Support For XML
- We use Accept in the header and try to access applicaton/json it will get the values but for application/xml the status is 406 Not Acceptable.	
- By adding the jackson-dataformat-xml dependency we can get the data in the xml format.

25. Monitoring APIs With Spring Boot Actuator
- In microservice architecture it is very important to create monitoring around your api's. 
- Acutator provides a lot of monitoring around your services. We need to use the hal browser dependincies also.
- localhost:8080/actuator or localhost:8080/application
- After defining management.endpoints.web.exposure.include=* in application.properties you will get lot of urls that you can use.
- In localhost:8080 you will get the hal browser.
- We can use hal browser to browse through the actuator. Enter /acutator and then Go.
- auditevents show the users authenticated and the users failed.
- beans show all the spring beans configured.
- conditions - Autoconfiguration
- In metrics you can see the metrics 
- httptraces - shows all the request that were executed. You cannot enable in production as it will have performance issues.
- mappings - shows all the different things that are mapped.

26. Implementing Static Filtering For RESTful Service
- You don't want to send password field in you response. You want to filer out a field. In that case we go for filtering.
- We can use @JsonIgnore to filter a field out or we can use @JsonIgnoreProperties(value={"field1", "field2"}).

27. Implementing Dynamic Filtering For RESTful Service
- With dynamic filtering we cannot configure filtering directly on the bean.

28. Versioning RESTful Services - Basic Approach with URIs
- See the project.

29. Versioning RESTful Services - Header And Content Negotiation Approach
- We use the uri localhost:8080/person/param?version=2 in postman using RequestParam
- To test versioning using Header Versioning us need to add the X-API-VERSION in the key in headers in postman and 1 / 2 as value
- To versioning using produces which is also called Content Negotiation or Accept Versioning in headers in key enter Accept and for value use application/vnd.company.app-v1+json / v2

- Media Type Versioning (a.k.a "content negotiation" or "accept header")
	- Github
- (Custom) Headers Versioning
	- Microsoft

- URI Versioning
	- Twitter
- Request Parameter Versioning
	- Amazon
- Factors 
	- URI Pollution
	  - If you look at the URI versioning and the Request Paramter versioning, we are actually polluting the URI space. So we are   actually creating new URIs or creating new request parameters as part of the URIs. 

	- Misuse of HTTP Headers
	  - Whereas in Media Type Versioning & Headers Versioning we are actually not polluting the URI space at all. These two do, what is called misuse of HTTP headers. HTTP header were never intended for versioning. 

	- Caching
	  - Media Type Versioning & Headers Versioning these two approaches use headers to differentiate between the requests, the caching can never come into picture because I cannot cache requests because they have the same URI. I would also need to look at the headers and do complicated things like that. So caching becomes very difficult here. But in these two options URI versioning and request paramter versioning I can still cache them because the version is part of the URI. 

	- Can we execute the request on the browser?
	  - What we did was, we executed all the requests using REST service client Postman. But think about a end user of your application. Probably most of them would be using a browser. So will they be able to execute the requests on the browser. For these two, No. For the media type versioning and custom header versioning. You cannot execute them on the normal browser. You have to actually have some kind of a plugin and the user has to have some kind of technical knowledge to be able to configure a HTTP header, HTTP request header and send the request out. But if you are using URL versioning or request parameter versioning, even a normal user would be able to fire a request very easily. I mean …I’m obviously talking about just the request to retrieve the data. As far as the request to..let’s say create something or update something, you would anyway need to send the body and that would definitely need a little bit of technical knowledge.

	- API Documentation
	  - You need to ensure that whatever thing that you are using is documented very well so your consumers know how to send the versioning input to your service. So you need to document that. And with the URI versioning and the Request Parameter versioning the documentation is a little easy because you can directly generate it out of code. But with the others it might be a little difficult to generate documentation out of code.

- No Perfect Solution: The important thing to realize is there is no perfect solution. It means there is no solution which would fit everybody.

- The recommended thing you to do is when you are starting building your APIs, finalize your versioning. So before you build your first API, have your versioning strategy really. Build a few examples of it, test them, make sure they are all working for your needs. That's the best you can do.

30. Implementing Basic Authentication With Spring Security
- Basic Authentication: Here you send userId and password as part of your request. Only when you provide those userId and password you would be able to access the resource.
- Digest Authenticatoin: Here the password digest is created and the digest is sent accross the actual password is not sent to the server.
- OAuth or OAuth2 Auhenticatoin: 
We will implement the basic authentication. For this add the spring security dependency. Once you restart the project you can see Using default security password printed in the console. Now when you fire the request in the postman you will get unauthrized error. In Auth of postman select BasicAuth and enter the default username as user and the password copied from log. Now once you hit you will get the response. Every time you start the password changes hence you can configure it in the application.properties file as 

spring.security.user.name=username
spring.security.user.password=password

31. Creating User Entity And Some Test Data
- uri: localhost:8080/h2-console - To go to h2 console.
- You have to just write the sql quries in data.sql file automatically the data inserted in the table by spring boot.

32. Updating GET Methods On User Resource to use JPA
- See the project.

33. Updating POST And DELETE Methods On User Resource To Use JPA
- See the project.

34. Creating Post Entity And Many To One Relationship With User Entity
- See the project.

35. Implementing A GET Service To Retrieve All Posts Of A User
- See the project. 

36. Implementing A POST Service To Create A Post For A User
- See the project.

40. Richardson Maturity Model
- See the .vtt file.

41. RESTful Web Services - Best Practices
- See the .vtt file.

42. Introduction To Microservices
- Small autonomous services that work together.
- Mircroservices are services which are exposed by rest have small well chosen deployable units these units should be cloud enabled.

43. Challenges With Microservices
- Deciding what is the right bound to microservices.
- Problem of configuration management.
- Dynamic scale up and scale down (Dynamic Load balancing).
- How to identify the bug & monitoring.
- Fault tolerance in microservices.

44. Introduction To Spring Cloud
- Configuration Management - Spring Cloud Config Server.
- Dynamic Scale Up & Scale Down
  	Ribbon For Client Side Load Balancing.
  	Naming Server (Eureka)
  	Feign (Easier Rest Clients)

- Visibility & Monitoring
  	Zipkin Distributed Tracing
  	Netflix API Gateway

- Fault Tolerance
	Hystrix

44. Advantages of Microservices Architectures
- Enables to adapt new technology & process it easily.
- You can build the microservices in different technologies.
- Dynamic Scaling.


45. Microservice Components - Standardizing Ports And URL	
- See the image.
- Use the url https://github.com/in28minutes/spring-microservices/tree/master/03.microservices





